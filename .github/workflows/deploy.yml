name: Build and Deploy to EC2

on:
  push:
    branches:
      - main

env:
  IMAGE_NAME: fruit-vegetable-store
  CONTAINER_NAME: fruit-vegetable-store
  APP_PORT: 3000
  INSTANCE_TAG_NAME: fruit-vegetable-store-app
  ECR_REPOSITORY: fruit-vegetable-store

jobs:
  deploy:
    runs-on: ubuntu-latest
    permissions:
      contents: read

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Determine deploy mode
        id: deploy_mode
        env:
          EC2_HOST: ${{ secrets.EC2_HOST }}
        run: |
          set -euo pipefail
          if [ -n "${EC2_HOST:-}" ]; then
            echo "use_static_host=true" >> "$GITHUB_OUTPUT"
            echo "host=$EC2_HOST" >> "$GITHUB_OUTPUT"
            echo "Using provided EC2_HOST."
          else
            echo "use_static_host=false" >> "$GITHUB_OUTPUT"
            echo "No EC2_HOST provided; workflow will resolve/provision EC2 via AWS API."
          fi

      - name: Validate required configuration
        env:
          EC2_HOST: ${{ secrets.EC2_HOST }}
          EC2_SSH_KEY: ${{ secrets.EC2_SSH_KEY }}
          AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          AWS_REGION: ${{ secrets.AWS_REGION || vars.AWS_REGION }}
          EC2_AMI_ID: ${{ secrets.EC2_AMI_ID }}
          EC2_INSTANCE_TYPE: ${{ secrets.EC2_INSTANCE_TYPE }}
          EC2_KEY_PAIR_NAME: ${{ secrets.EC2_KEY_PAIR_NAME }}
          EC2_SECURITY_GROUP_ID: ${{ secrets.EC2_SECURITY_GROUP_ID }}
          EC2_SUBNET_ID: ${{ secrets.EC2_SUBNET_ID }}
          APP_DOMAIN: ${{ secrets.APP_DOMAIN || vars.APP_DOMAIN }}
        run: |
          set -euo pipefail

          require_non_empty() {
            local var_name="$1"
            local value="$2"
            if [ -z "$value" ]; then
              echo "Missing required setting: $var_name" >&2
              exit 1
            fi
          }

          require_non_empty "EC2_SSH_KEY" "${EC2_SSH_KEY:-}"
          require_non_empty "AWS_ACCESS_KEY_ID" "${AWS_ACCESS_KEY_ID:-}"
          require_non_empty "AWS_SECRET_ACCESS_KEY" "${AWS_SECRET_ACCESS_KEY:-}"
          require_non_empty "AWS_REGION (secret or variable)" "${AWS_REGION:-}"
          require_non_empty "APP_DOMAIN (secret or variable)" "${APP_DOMAIN:-}"

          if [ "${{ steps.deploy_mode.outputs.use_static_host }}" = "true" ]; then
            require_non_empty "EC2_HOST" "${EC2_HOST:-}"
          else
            require_non_empty "EC2_AMI_ID" "${EC2_AMI_ID:-}"
            require_non_empty "EC2_INSTANCE_TYPE" "${EC2_INSTANCE_TYPE:-}"
            require_non_empty "EC2_KEY_PAIR_NAME" "${EC2_KEY_PAIR_NAME:-}"
            require_non_empty "EC2_SECURITY_GROUP_ID" "${EC2_SECURITY_GROUP_ID:-}"
            require_non_empty "EC2_SUBNET_ID" "${EC2_SUBNET_ID:-}"
          fi

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ secrets.AWS_REGION || vars.AWS_REGION }}

      - name: Resolve or create EC2 instance
        if: steps.deploy_mode.outputs.use_static_host != 'true'
        id: ec2
        env:
          EC2_AMI_ID: ${{ secrets.EC2_AMI_ID }}
          EC2_INSTANCE_TYPE: ${{ secrets.EC2_INSTANCE_TYPE }}
          EC2_KEY_PAIR_NAME: ${{ secrets.EC2_KEY_PAIR_NAME }}
          EC2_SECURITY_GROUP_ID: ${{ secrets.EC2_SECURITY_GROUP_ID }}
          EC2_SUBNET_ID: ${{ secrets.EC2_SUBNET_ID }}
        run: |
          set -euo pipefail

          EXISTING_INSTANCE_ID=$(aws ec2 describe-instances \
            --filters "Name=tag:Name,Values=${INSTANCE_TAG_NAME}" "Name=instance-state-name,Values=pending,running,stopping,stopped" \
            --query "Reservations[].Instances[].InstanceId" \
            --output text | awk '{print $1}')

          if [ -n "${EXISTING_INSTANCE_ID:-}" ] && [ "$EXISTING_INSTANCE_ID" != "None" ]; then
            echo "Reusing instance: $EXISTING_INSTANCE_ID"
            CURRENT_STATE=$(aws ec2 describe-instances --instance-ids "$EXISTING_INSTANCE_ID" --query "Reservations[0].Instances[0].State.Name" --output text)
            if [ "$CURRENT_STATE" = "stopped" ]; then
              aws ec2 start-instances --instance-ids "$EXISTING_INSTANCE_ID" >/dev/null
            fi
            INSTANCE_ID="$EXISTING_INSTANCE_ID"
          else
            USER_DATA=$'#!/bin/bash\nset -eux\napt-get update\napt-get install -y docker.io nginx\nsystemctl enable docker\nsystemctl start docker\nsystemctl enable nginx\nsystemctl start nginx\nusermod -aG docker ubuntu || true'

            INSTANCE_ID=$(aws ec2 run-instances \
              --image-id "$EC2_AMI_ID" \
              --instance-type "$EC2_INSTANCE_TYPE" \
              --key-name "$EC2_KEY_PAIR_NAME" \
              --security-group-ids "$EC2_SECURITY_GROUP_ID" \
              --subnet-id "$EC2_SUBNET_ID" \
              --tag-specifications "ResourceType=instance,Tags=[{Key=Name,Value=${INSTANCE_TAG_NAME}}]" \
              --user-data "$USER_DATA" \
              --query 'Instances[0].InstanceId' \
              --output text)
            echo "Created instance: $INSTANCE_ID"
          fi

          aws ec2 wait instance-running --instance-ids "$INSTANCE_ID"
          HOST=$(aws ec2 describe-instances --instance-ids "$INSTANCE_ID" --query "Reservations[0].Instances[0].PublicIpAddress" --output text)
          echo "host=$HOST" >> "$GITHUB_OUTPUT"

      - name: Select final deploy host
        id: final_host
        run: |
          set -euo pipefail
          if [ "${{ steps.deploy_mode.outputs.use_static_host }}" = "true" ]; then
            echo "host=${{ steps.deploy_mode.outputs.host }}" >> "$GITHUB_OUTPUT"
          else
            echo "host=${{ steps.ec2.outputs.host }}" >> "$GITHUB_OUTPUT"
          fi

      - name: Ensure ECR repository exists
        run: |
          set -euo pipefail
          aws ecr describe-repositories --repository-names "$ECR_REPOSITORY" >/dev/null 2>&1 || \
          aws ecr create-repository --repository-name "$ECR_REPOSITORY" >/dev/null

      - name: Login to Amazon ECR
        id: ecr_login
        uses: aws-actions/amazon-ecr-login@v2

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Build and push production image to ECR
        env:
          ECR_REGISTRY: ${{ steps.ecr_login.outputs.registry }}
        run: |
          set -euo pipefail
          IMAGE_URI="$ECR_REGISTRY/$ECR_REPOSITORY:${{ github.sha }}"
          LATEST_URI="$ECR_REGISTRY/$ECR_REPOSITORY:latest"
          docker build --platform linux/amd64 -t "$IMAGE_URI" -t "$LATEST_URI" .
          docker push "$IMAGE_URI"
          docker push "$LATEST_URI"
          echo "image_uri=$IMAGE_URI" >> "$GITHUB_OUTPUT"
        id: image

      - name: Configure SSH key
        env:
          EC2_SSH_KEY: ${{ secrets.EC2_SSH_KEY }}
        run: |
          mkdir -p ~/.ssh
          echo "$EC2_SSH_KEY" > ~/.ssh/ec2_key
          chmod 600 ~/.ssh/ec2_key
          ssh-keyscan -H ${{ steps.final_host.outputs.host }} >> ~/.ssh/known_hosts

      - name: Wait for SSH readiness
        run: |
          for i in {1..30}; do
            if ssh -i ~/.ssh/ec2_key -o ConnectTimeout=5 -o StrictHostKeyChecking=yes ubuntu@${{ steps.final_host.outputs.host }} 'echo ok' >/dev/null 2>&1; then
              echo "SSH is ready"
              exit 0
            fi
            echo "Waiting for SSH... ($i/30)"
            sleep 10
          done
          echo "SSH did not become ready in time"
          exit 1

      - name: Deploy from ECR and configure Nginx reverse proxy
        env:
          AWS_REGION: ${{ secrets.AWS_REGION || vars.AWS_REGION }}
          ECR_REGISTRY: ${{ steps.ecr_login.outputs.registry }}
          APP_DOMAIN: ${{ secrets.APP_DOMAIN || vars.APP_DOMAIN }}
          IMAGE_URI: ${{ steps.image.outputs.image_uri }}
        run: |
          aws ecr get-login-password --region "$AWS_REGION" | \
          ssh -i ~/.ssh/ec2_key ubuntu@${{ steps.final_host.outputs.host }} "docker login --username AWS --password-stdin $ECR_REGISTRY"

          ssh -i ~/.ssh/ec2_key ubuntu@${{ steps.final_host.outputs.host }} << EOF
            set -e
            sudo apt-get update -y
            sudo apt-get install -y docker.io nginx
            sudo systemctl enable docker
            sudo systemctl start docker
            sudo systemctl enable nginx
            sudo systemctl start nginx

            docker pull $IMAGE_URI
            docker stop $CONTAINER_NAME || true
            docker rm $CONTAINER_NAME || true
            docker run -d \
              --name $CONTAINER_NAME \
              --restart unless-stopped \
              -p 127.0.0.1:$APP_PORT:3000 \
              -e NODE_ENV=production \
              $IMAGE_URI

            sudo tee /etc/nginx/sites-enabled/fruit-vegetable-store >/dev/null <<NGINX
            server {
              listen 80;
              server_name $APP_DOMAIN;

              location / {
                proxy_pass http://127.0.0.1:$APP_PORT;
                proxy_http_version 1.1;
                proxy_set_header Upgrade \$http_upgrade;
                proxy_set_header Connection 'upgrade';
                proxy_set_header Host \$host;
                proxy_set_header X-Real-IP \$remote_addr;
                proxy_set_header X-Forwarded-For \$proxy_add_x_forwarded_for;
                proxy_set_header X-Forwarded-Proto \$scheme;
                proxy_cache_bypass \$http_upgrade;
              }
            }
            NGINX

            sudo rm -f /etc/nginx/sites-enabled/default
            sudo nginx -t
            sudo systemctl reload nginx
          EOF
